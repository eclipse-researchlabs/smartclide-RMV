/*
 * Monitor Sensor Shared Variables Access
 *
 *   There are two distinct methods currently implemented
 *   and under consideration. The final approach will be
 *   some hybrid of the two, or perhaps choices will be
 *   preserved. There are interpretations of both methods
 *   contained in the curent implementation.
 * 
 *   The first method is generation of everything dynamically
 *   from the MS configuration vector. Carried to it's logical
 *   extreme, this method would require the service setter/
 *   getter to refer to the shared variables by their string
 *   name. A less extreme approach is to have a minimal
 *   include file to declare the shared variables as C variables.
 *   In this case the dynamic bit is used to establish the link
 *   between the string names and the C variable names.
 * 
 *   The second method depends more heavily on an include file,
 *   such as the example "monid_00002_vars.h" included by this
 *   file, it contains declarations specific to the service
 *   and monitor and more of the information to link to the
 *   shared vars.
 */

typedef char *sh_var_name;

typedef sh_var_name *sh_var_names; // pointer to (null-term) array of names

typedef union {
	int		sv_intval;
	bool	sv_boolval;
	float	sv_floatval;
	char	sv_charval;
	void*	sv_ptrval;
} sh_var_val;

typedef enum {
	svt_Byte,
	svt_String,
	svt_Boolean,
	svt_Integer,
	svt_Float,
	svt_Char,
	svt_Symbol,
	svt_Address
} sh_var_type;

// gets value of argument named variable
typedef sh_var_val (*get_sh_var_by_name)(sh_var_name);

// sets argument named variable to new value returning old value
typedef sh_var_val (*set_sh_var_by_name)(sh_var_name, sh_var_val);

// gets value of argument indexed variable
typedef sh_var_val (*get_sh_var_by_index)(int);

// sets argument indexed variable to new value returning old value
typedef sh_var_val (*set_sh_var_by_index)(int, sh_var_val);

typedef struct {
	sh_var_name sv_name;
	sh_var_type sv_type;
	sh_var_val* sv_addr; // alternative to access non-trigger vars
	bool sv_trigger; // setter triggers responder()
	bool sv_report; // included in MS heartbeat reports
	bool sv_property_eval; // needed for property eval
	get_sh_var_by_index sv_getter;
	set_sh_var_by_index sv_setter;
} shared_var_attributes;

typedef shared_var_attributes *shared_var_attributesp;

//shared_var_attributesp shared_vars;

int n_shared_vars;

// The following include provides service/monitor-specific
// declarations generated by monitor creation
#include "monid_00002_vars.h"

set_sh_var_by_index setter_by_type[] = {
	NULL, // &byte_setter,
	NULL, // &string_setter,
	&bool_setter,
	&int_setter,
	&float_setter,
	NULL, // &char_setter,
	NULL, // &symbol_setter,
	NULL, // &addr_setter
};

get_sh_var_by_index getter_by_type[] = {
	NULL, // &byte_getter,
	NULL, // &string_getter,
	&bool_getter,
	&int_getter,
	&float_getter,
	NULL, // &char_getter,
	NULL, // &symbol_getter,
	NULL, // &addr_getter
};

// length of null-terminated array of pointers
int len_narr(void* arr[]){
	int i; for(i=0; *arr++; i++) ;
	return(i);
}

sh_var_val *alloc_sh_var(sh_var_type vartype){
	switch(vartype){
		case svt_Byte: break;
		case svt_String: break;
		case svt_Boolean:
			return( calloc(1,sizeof(bool)) );
		case svt_Integer: break;
			return( calloc(1,sizeof(int)) );
		case svt_Float: break;
			return( calloc(1,sizeof(float)) );
		case svt_Char: break;
		case svt_Symbol: break;
		case svt_Address: break;
		default: break;
	}
	return NULL;
}