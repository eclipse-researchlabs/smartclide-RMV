//#define MS_TEST
#define VERBOSITY 0
#define VERBOSE(L) if(VERBOSITY >= L)
#define VERBOSE_MSG(L,M) if(VERBOSITY >= L){printf(M);fflush(stdout);}
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <float.h>
#include <limits.h>
#include <ctype.h>

#define JSMN_PARENT_LINKS
#include "jsmn.h"

// TODO - check these limits (only) during configuration initialization
#define JSON_STRING_SIZE 2048
#define JSMN_TOKEN_ARRAY_SIZE 1024
#define CHARS_SZ 4096
#define STRINGS_SZ 1024
#define SH_VAR_SZ 20
#define MON_ATOM_SZ 20
#define ATOM_OP_MAX_LEN 20
#define ATOM_ARG_MAX_LEN 50

typedef enum mstatus {
    monitor_uninitialized,
    monitor_initialized,
    monitor_started,
    monitor_stopping
} mstatus;

// TODO - make this an array
char *mstatus_string(mstatus ms){
    switch(ms){
        case monitor_uninitialized: return("monitor_uninitialized");
        case monitor_initialized: return("monitor_initialized");
        case monitor_started: return("monitor_started");
        case monitor_stopping: return("monitor_stopping");
    }
}

typedef char **sh_var_names; // pointer to (null-term) array of names

typedef union {
	bool	sv_boolval;
	int		sv_intval;
	float	sv_floatval;
	char	sv_charval;
	void*	sv_addrval;
} sh_var_val;

typedef enum sh_var_type {
	svt_Byte,       // unused
	svt_String,     // unused
	svt_Boolean,
	svt_Integer,
	svt_Float,
	svt_Char,       // unused
	svt_Symbol,     // unused
	svt_Address,
	svt_VAR,
	svt_UNDEFINED
} sh_var_type;

static char* sv_type_names[] = {"Byte","String","Boolean","Integer",
				"Float","Char","Symbol","Address","VAR","UNDEFINED"};

// sh_var_name_value struct is
// used to stage sh var initializations specified in the JSON
// and variable value reports made for MS heartbeat messages.
typedef struct sh_var_name_value {
    char *vnv_name;
    char *vnv_value;
    sh_var_type vnv_type;
} sh_var_name_value;

typedef void(*getr_t)(void*);
typedef void(*setr_t)(void*,void*);

typedef struct {
	char *va_name;
	sh_var_type va_type;
	void* va_addr;
	bool va_trigger; // trigger responder() when var is set
	bool va_report; // include var in MS heartbeat reports
	bool va_property_eval; // var used in property eval
	getr_t va_getter;
	setr_t va_setter;
} shared_var_attr_t;

// string repr of declarations appering in JSON configuration vector
typedef struct {
    char *name; char *type;
} sh_var_decl;

typedef enum atom_op {
    var, not, bcon_f, bcon_t, eq, ne, gt, lt, ge, le, badop
} atom_op;

static char *atom_op_names[] = {
    "__var__", "not", "false", "true", // synonyms too much trouble
    "eq", "ne", "gt", "lt", "ge", "le", /*"neq", "geq", "leq",*/ "badop"
};

static atom_op atom_op_map[] = {
    var, not, bcon_f, bcon_t,
    eq, ne, gt, lt, ge, le, /* ne, ge, le,*/ badop
};

typedef enum ext_atom_op {
    eq_B_B, eq_I_I, eq_F_F, eq_I_F,
    ne_B_B, ne_I_I, ne_F_F, ne_I_F,
    lt_I_I, lt_F_F, lt_I_F, lt_F_I,
    le_I_I, le_F_F, le_I_F, le_F_I,
    var_B, var_I,
    not_B, not_I,
    Bfalse, Btrue,
    inval_op
} ext_atom_op;

static char *ext_atom_op_names[] = {
    "eq_B_B", "eq_I_I", "eq_F_F", "eq_I_F",
    "ne_B_B", "ne_I_I", "ne_F_F", "ne_I_F",
    "lt_I_I", "lt_F_F", "lt_I_F", "lt_F_I",
    "le_I_I", "le_F_F", "le_I_F", "le_F_I",
    "var_B", "var_I",
    "not_B", "not_I",
    "Bfalse", "Btrue",
    "inval_op"
};

typedef enum a_arg_kind {
    akind_variable, akind_constant, akind_unused
} a_arg_kind;

static char *akind_names[] = {
    "variable", "constant", "unused"
};

// includes string representation of monitor atoms as appearing
// in JSON configuration vector and compiled representation
typedef struct monitor_atom { // NEW
    char        *ma_aid;
    char        *ma_aex;       // e.g.: "eq(n,2)" ==>

    atom_op     ma_op;          // literal op, e.g. eq
    ext_atom_op ma_ext_op;      // op with explicit types, e.g. eq_I_I

    a_arg_kind  ma_arg1_knd; // e.g. akind_var
    sh_var_type ma_arg1_typ;    // svt_Integer
    sh_var_val  ma_arg1_val;    // (sv_addrval)

    a_arg_kind  ma_arg2_knd; // e.g. akind_const
    sh_var_type ma_arg2_typ;    // svt_Integer
    sh_var_val  ma_arg2_val;    // (sv_intval)
} monitor_atom;
/* OLD
typedef struct monitor_atom {
    char        *ma_aid;
    char        *ma_aex;       // e.g.: "eq(n,2)" ==>
    atom_op     ma_op;          // eq
    sh_var_type ma_arg1_typ;    // svt_Address
    sh_var_val  ma_arg1_val;    // (sv_addrval)
    sh_var_type ma_arg2_typ;    // svt_Integer
    sh_var_val  ma_arg2_val;    // (sv_intval)
} monitor_atom;
*/

/*
% MS CONFIGURATION STRUCTURE
%   A JSON version of this structure is generated by Monitor Creation to accompany
%   the generated monitor. It is initialized by initialize_ms_configuration
%
%   monitor_id - established when the Monitor Sensor is defined
%   shared_vars - all variables shared by SUS and MS - superset of all other vars
%   observable_vars - SUS variables used in model, properties or reportable (may be same as shared)
%   model_vars (subset of shared_vars) - potentially observable SUS variables in the model
%   property_vars - observable vars used in property evaluation
%   reportable_vars - subset of monitor_observables to be reported in heartbeat
%   trigger_vars - variables for which setter should trigger responder
%   monitor_atoms - list of atoms {aid: , aex: } to be evaluated
%   monitor_atom_eval - where atoms are evaluated (unset_eval, ms_eval or mep_eval)
%   shared_vars_init - optional initializations list of {name: , value: }
*/
typedef struct ms_configuration_vector { // TODO - compare w/ms_pl
    char *monitor_id;
    sh_var_decl *shared_var_decls;
    char **observable_vars;
    char **model_vars;
    char **property_vars;
    char **reportable_vars;
    char **trigger_vars;
    monitor_atom *monitor_atoms;
    int n_monitor_atoms;
    char *monitor_atom_eval;
    sh_var_name_value *shared_var_inits;
} ms_configuration_vector;

static char *cv_element_names[] = {
  "monitor_id",
  "shared_var_decls",
  "observable_vars",
  "model_vars",
  "property_vars",
  "reportable_vars",
  "trigger_vars",
  "monitor_atoms",
  "n_monitor_atoms",
  "monitor_atom_eval",
  "shared_var_inits",
  "name",
  "type",
  "value",
  "aid",
  "aex"
};

/*
 * MONITOR INTERFACE STRUCTURE
 */

// info the SUS/MS may need to properly set up and interact with the monitor
typedef struct {
    mstatus mi_mstatus;
    shared_var_attr_t *mi_shared_vars;
    int mi_num_shared_vars;
    char *mi_JSON_cv;
    ms_configuration_vector mi_cv;
    char *mi_sessid;
} monitor_interface_t;

// allocate and minimally initialize the global monitor_interface instance
monitor_interface_t monitor_interface = {
    /* mi_mstatus */            monitor_uninitialized,
    /* mi_shared_vars */        NULL,
    /* mi_num_shared_vars */    0,
    /* mi_JSON_cv */            "\0",
    /* mi_cv*/ {
        /* monitor id */        "",
        /* shared_var_decls */  NULL,
        /* observable_vars */   NULL,
        /* model_vars */        NULL,
        /* property_vars */     NULL,
        /* reportable_vars */   NULL,
        /* trigger_vars */      NULL,
        /* monitor_atoms */     NULL,
        /* n_monitor_atoms */  0,
        /* monitor_atom_eval */ "unset_eval",
        /* shared_var_inits */  NULL
    },
    /* mi_sessid */             ""
};

sh_var_decl sh_var_decls[SH_VAR_SZ];
sh_var_decl *next_sh_var_decl = sh_var_decls;
sh_var_name_value sh_var_name_values[SH_VAR_SZ];
sh_var_name_value *next_sh_var_name_value = sh_var_name_values;
// TODO - dynamically allocate just what's needed using the count
// field in the parsed JSON structure; assign ptr in ms_cv;
// iterate over monitor_atom structs using n_monitor_atoms,
monitor_atom monitor_atoms[MON_ATOM_SZ];
monitor_atom *next_monitor_atom = monitor_atoms;

// JSON string to be read in from file, stream or other argument
static char JSON_STRING[JSON_STRING_SIZE] = "";

// forward declaration of dump functions
void dump_sh_vars();
void dump_shared_var_attributes(void *, int);
void dump_sv_inits(char *);
void dump_matoms(char *);
void dump_strings(char*, char**);
void dump_compiled_atoms();
void dump_parse(char*);

// other forward function declarations
int int_setter_by_addr(int*, int);
int int_setter_by_idx(int, int);
int int_setter_by_name(char*, int);

bool bool_setter_by_addr(bool*, bool);
bool bool_setter_by_idx(int, bool);
bool bool_setter_by_name(char*, bool);

float float_setter_by_addr(float*, float);
float float_setter_by_idx(int, float);
float float_setter_by_name(char*, float);

/////////////////////////////
// This include file provides service/monitor-specific
// declarations generated by monitor creation. The file
// will be changed to a generic name once this file is
// automatically generated. (monitor_vars.h)
/////////////////////////////

#include "monid_00002_vars.h"

/////////////////////////////

#include "ms_vars.h"
#include "ms_json.h"
#include "ms_conf.h"
#include "ms_iface.h"
#include "ms_dump.h"

// currently not safe for multi-threaded service-under-scruting (SUS)
// if multiple threads call responder() or set trigger vars
// due to structures used during responder() processing

#ifdef MS_TEST
#include "ms_test.h"
#endif